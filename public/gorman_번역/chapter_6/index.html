<!DOCTYPE html>
<html lang="en">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-DW95HBTSYY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-DW95HBTSYY');
</script>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.5">
    <title>Chapter 6 Physical Page Allocation</title>
    <link rel="stylesheet" href="/css/styles.css">
</head>
<body>
    <main class="content">
        
<article>
    <h1>Chapter 6 Physical Page Allocation</h1>
    <div class="post-content">
        <p>이 글은 Gorman 책 &ldquo;Understanding the Linux Virtual Memory Manager&quot;의 <a href="https://www.kernel.org/doc/gorman/html/understand/understand009.html">Chapter 6</a>를 번역한 글입니다.</p>
<hr>
<p>이 챕터에서는 리눅스에서 물리 페이지들이 어떻게 관리되고 할당되는지를 설명한다. 이에 관련하여 사용되는 주요 알고리즘은 Binary Buddy Allocator로, Knowlton이 고안했고, Knuth가 발전시켰다. 이 알고리즘은 다른 할당자들과 비교하였을 때 굉장히 빠른 성능을 보여준다.</p>
<p>이는 일반적인 2의 거듭제곱 할당자에 free 버퍼 합체 기술을 결합한 할당 scheme이며, 기본 컨셉은 꽤 간단하다. 메모리는 2의 거듭제곱의 페이지로 구성된 큰 페이지 블록들로 나누어진다. 만약 원하는 크기의 블록이 없는 경우, 큰 블록은 서로에게 buddy인 두 개의 블록으로 반으로 쪼개어진다. 이 중 하나는 할당에 사용되고, 나머지는 free 상태가 된다. 필요한 경우, 원하는 크기의 블록이 생길 때까지 이를 반복한다. 블록이 해제되는 경우, 버디를 체크하여 free하면 둘을 합체하여 큰 블록으로 만든다.</p>
<p>이 챕터는 리눅스가 어떤 메모리 블록이 free한지를 기억하는 방법을 설명한다. 그 후 페이지를 할당하고 해제하는 방법에 대해 자세히 설명한다. 그런 다음 할장자의 동작에 영향을 주는 플래그들에 대해서 다루고, 마지막으로 단편화 문제에 대해 설명하고, 할당자가 이를 어떻게 처리하는 지를 설명한다.</p>
<h2 id="61-managing-free-blocks">6.1 Managing Free Blocks</h2>
<p>앞서 말했듯이, 할당자는 2의 거듭제곱개의 페이지로 구성된 free 페이지 블록을 관리한다. 블록의 2의 지수값을 order라고 한다. Figure 6.1에서 확인할 수 있듯이, free_area_t 구조체의 배열이 관리되며, 각 요소는 인덱스에 해당하는 order의 페이지 블록들로 구성된 linked list를 가리킨다.</p>
<hr>
<p>
  <figure>
    <img src="/images/gorman_%eb%b2%88%ec%97%ad/figure6.1.png" alt="Figure 6.1">
    <figcaption>Figure 6.1: Free page block management</figcaption>
  </figure>

</p>
<hr>
<p>그러므로, 배열의 0번째 요소는 2^0, 즉 1개의 페이지로 구성된 free 페이지 블록의 리스트를 가리킬 것이며, 1번째는 2^1(=2)개의 페이지를, MAX_ORDER-1 번째는 2^(MAX_ORDER-1)개의 페이지들의 리스트를 가리킬 것이다 (MAX_ORDER는 현재에는 10으로 정의되어있다). 이는 작은 블록이 충분함에도 큰 블록을 쪼개는 상황이 발생할 확률을 제거한다. 페이지 블록들은 page-&gt;list를 통해 linear linked list로 관리된다</p>
<p>각 존은 free_area_t 구조체의 배열인 free_area[MAX_ORDER]을 가진다. 이는 &lt;linux/mm.h&gt;에 다음과 같이 선언된다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">22</span> <span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> free_area_struct {
<span style="color:#ae81ff">23</span>         <span style="color:#66d9ef">struct</span> list_head        free_list;
<span style="color:#ae81ff">24</span>         <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>           <span style="color:#f92672">*</span>map;
<span style="color:#ae81ff">25</span> } free_area_t; 
</code></pre></div><p>각 필드의 의미는 다음과 같다:</p>
<ul>
<li>free_list: free page block의 linked list이다.</li>
<li>map: 버디 쌍의 상태를 표현하는 비트맵이다.</li>
</ul>
<p>리눅스는 각 버디 쌍마다 두 비트 대신 하나의 비트만 사용함으로써 메모리를 절약한다. 버디가 할당되거나 해제될 때마다, 버디 쌍에 해당하는 비트가 전환되는데, 버디가 모두 free하거나 할당된 경우 0으로 설정되고, 둘 중 하나만 할당된 경우에 1로 설정된다. 비트의 전환은 page_alloc.c에 존재하는 MARK_USED() 매크로가 수행하며, 이는 다음과 같이 선언되어있다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#ae81ff">164</span> <span style="color:#960050;background-color:#1e0010">#</span>define MARK_USED(index, order, area) \
<span style="color:#ae81ff">165</span>         __change_bit((index) <span style="color:#f92672">&gt;&gt;</span> (<span style="color:#ae81ff">1</span><span style="color:#f92672">+</span>(order)), (area)<span style="color:#f92672">-&gt;</span>map)
</code></pre></div><p>Index는 페이지의 전역 mem_map 배열 내에서의 위치를 의미한다. 이것을 오른쪽으로 1+order 만큼 쉬프트하면, 배열 내에서 버디쌍의 위치를 계산할 수 있다.</p>
<h2 id="62-allocating-pages">6.2 Allocating Pages</h2>
<p>리눅스는 페이지 프레임의 할당을 위해 꽤 많은 API들을 제공한다. 그들은 모두 gfp_mask를 인자로 받는데, 이는 할당자가 어떻게 동작할 지를 결정하기 위한 플래그들의 집합이다. 플래그들은 섹션 6.4에서 설명한다.</p>
<p>할당 API들은 모두 핵심 함수인 __alloc_pages()를 사용하지만, 정확한 노드와 존을 선택하기 위해 API가 존재한다. 유저는 서로 다른 존을 필요로 할 것이다. 예를 들면, 장치 드라이버는 ZONE_DMA를 요구할 것이고, 디스크 버퍼는 ZONE_NORMAL을 요구할 것이다. 또한 호출자는 어떤 노드가 사용되는 지에 대해 알 필요는 없을 것이다. 페이지 할당 API의 전체 리스트는 Table 6.1에서 확인할 수 있다.</p>
<hr>






  
  
  


  




<div class="table-wrapper" role="region" tabindex="0" aria-labelledby="table-caption-769431825">
  <table class="table " id="769431825" itemscope itemtype="https://schema.org/Table"><caption id="table-caption-769431825" itemprop="about">Table 6.1: Physical Pages Allocation API</caption>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>struct page * alloc_page(unsigned int gfp_mask)</td>
</tr>
<tr>
<td>페이지 1개를 할당하고 struct page의 주소를 반환한다.</td>
</tr>
<tr>
<td>struct page * alloc_pages(unsigned int gfp_mask, unsigned int order)</td>
</tr>
<tr>
<td>2^order 개의 페이지들을 할당하고 struct page의 주소를 반환한다.</td>
</tr>
<tr>
<td>unsigned long get_free_page(unsigned int gfp_mask)</td>
</tr>
<tr>
<td>페이지 1개를 할당하고, 0으로 초기화한 후, 이것의 가상 주소를 반환한다.</td>
</tr>
<tr>
<td>unsigned long __get_free_page(unsigned int gfp_mask)</td>
</tr>
<tr>
<td>페이지 1개를 할당하고, 가상 주소를 반환한다.</td>
</tr>
<tr>
<td>unsigned long __get_free_pages(unsigned int gfp_mask, unsigned int order)</td>
</tr>
<tr>
<td>2^order개의 페이지들을 할당하고 가상 주소를 반환한다.</td>
</tr>
<tr>
<td>struct page * __get_dma_pages(unsigned int gfp_mask, unsigned int order)</td>
</tr>
<tr>
<td>2^order개의 페이지들을 DMA 존에서 할당하고 struct page의 주소를 반환한다.</td>
</tr>
</tbody>
</table>

</div>

<hr>
<p>할당할 때에는 항상 특정 order을 인자로 전달해야한다. 단일 페이지의 경우에는 0을 전달해야한다. 만약 해당 order에 대한 free 블록을 찾지 못한 경우, 더 높은 order의 블록을 두 개의 버디로 쪼갠다. 이 중 하나는 할당되고 나머지는 낮은 order의 free list에 삽입된다. Figure 6.2는 2^4 블록이 프로세스가 요구하는 크기의 블록으로 쪼개지면서 free list에 추가되는 과정을 나타낸다.</p>
<hr>
<p>
  <figure>
    <img src="/images/gorman_%eb%b2%88%ec%97%ad/figure6.2.png" alt="">
    <figcaption>Figure 6.2: Allocating physical pages</figcaption>
  </figure>

</p>
<hr>
<p>블록이 해제되면, 버디를 체크할 것이다. 만약 두 블록이 모두 해제된 상태라면 그들은 더 높은 order의 블록으로 병합되고 해당 order의 free list에 삽입되며, 다시 해당 order에서의 버디를 체크하는 과정을 반복한다. 만약 버디가 할당된 상태라면, 해제된 블록은 현재 order의 free list에 삽입된다. free list를 조작하는 동안에는 인터럽트를 비활성화하여, 프로세스가 free list를 수정하는 도중에 인터럽트 핸들러가 리스트를 조작하는 일이 없도록 해야한다. 이를 위해 interrupt safe spinlock을 사용한다.</p>
<p>order를 결정했다면, 두 번째로는 어떤 메모리 노드 또는 pg_data_t를 사용할지를 결정해야한다. 리눅스는 node-local 할당 정책을 사용하며, 이는 페이지를 할당하는 프로세스가 돌고있는 CPU에 가까운 메모리 뱅크를 우선적으로 사용하는 정책을 말한다. 이와 관련해서 _alloc_pages() 함수가 중요하며, 이 함수는 UMA인지 NUMA인지에 따라 다른 코드로 컴파일이 된다.</p>
<p>어떤 API가 사용되는지에 상관없이, mm/page_alloc.c의 __alloc_pages() 함수가 할당의 심장 역할을 한다. 이 함수는 절대 직접 호출되지않으며, 선택된 존을 조사하고 필요한 페이지 수를 할당하기에 적합한지를 검사한다. 만약 존이 적합하지않다면, 할당자는 다른 존으로 폴백(fall back)할 것이다. 폴백하는 존의 순서는 build_zonelists()에 의해 부트 타임에 결정되지만 일반적으로 ZONE_HIGHMEM, ZONE_NORMAL, 그리고 ZONE_DMA 순으로 폴백한다. 만약 free 페이지의 수가 pages_low 워터마크에 도달한다면, 이는 <strong>kswapd</strong>를 깨워 존들로부터 페이지들을 해제하도록 할 것이다. 하지만 만약 메모리가 극단적으로 부족한 상황이라면, 할당자는 <strong>kswapd</strong>의 일을 직접 할 것이다.</p>
<hr>
<p>
  <figure>
    <img src="/images/gorman_%eb%b2%88%ec%97%ad/figure6.3.png" alt="">
    <figcaption>Figure 6.3: Call Graph: alloc_pages()</figcaption>
  </figure>

</p>
<hr>
<p>할당할 존이 결정되고나면, rmqueue()가 호출되어 페이지 블록을 할당하거나, 만약 적절한 크기의 블록이 없다면 큰 블록을 쪼갤 것이다.</p>
<h2 id="63-free-pages">6.3 Free Pages</h2>
<p>페이지의 해제를 위한 API는 매우 간단하고, 버디 할당자의 한가지 단점이 호출자가 할당했던 크기를 기억하고있어야 한다는 것이기 때문에, 이를 기억하도록 돕기위해 API가 존재한다. 해제를 위한 API는 Table 6.2에 나와있다.</p>
<hr>






  
  
  


  




<div class="table-wrapper" role="region" tabindex="0" aria-labelledby="table-caption-197568423">
  <table class="table " id="197568423" itemscope itemtype="https://schema.org/Table"><caption id="table-caption-197568423" itemprop="about">Table 6.2: Physical Pages Free API</caption>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>void __free_pages(struct page *page, unsigned int order)</td>
</tr>
<tr>
<td>주어진 page로부터 2^order 개의 페이지를 해제한다.</td>
</tr>
<tr>
<td>void __free_page(struct page *page)</td>
</tr>
<tr>
<td>단일 페이지를 해제한다.</td>
</tr>
<tr>
<td>void free_page(void *addr)</td>
</tr>
<tr>
<td>주어진 가상 주소에 해당하는 페이지를 해제한다.</td>
</tr>
</tbody>
</table>

</div>

<hr>
<p>페이지 해제의 주요 함수는 __free_pages_ok()이며, 이는 직접 호출되서는 안된다. 대신에 __free_pages()가 제공되어, Figure 6.4에 나와있듯이 __free_pages_ok()를 호출하기 전에 간단한 검사들을 수행한다.</p>
<hr>
<p>
  <figure>
    <img src="/images/gorman_%eb%b2%88%ec%97%ad/figure6.4.png" alt="">
    <figcaption>Figure 6.4: Call Graph: __free_pages()</figcaption>
  </figure>

</p>
<hr>
<p>버디가 해제될 때, 리눅스는 버디 쌍을 가능하다면 즉시 병합하고자 시도한다. 최악의 경우에는 합쳐진 많은 버디들이 즉시 쪼개질 수 있기 때문에, 이러한 정책이 최적은 아니다.</p>
<p>버디들을 병합할 수 있는지를 판단하기위해, 리눅스는 free_area-&gt;map에서 버디 쌍에 해당하는 비트를 확인한다. 이 함수에 의해 하나의 버디가 해제된 상태기 때문에, 최소 하나의 버디가 free하다는 것은 명백히 알 수 있다. 만약 map의 비트가 0이라면, 우리는 다른 버디또한 free하다는 것을 알 수 있다. map의 비트가 0이라면 두 버디가 모두 할당되었거나 해제되었다는 것을 의미하기 때문이다. 따라서 비트가 0이면, 버디를 병합할 수 있다.</p>
<p>버디의 주소를 계산하는 방법은 잘 알려져있는 개념이다. 할당이 항상 2의 거듭제곱의 크기로 이루어지기 때문에, 블록의 주소 또는 최소한 이것의 zone_mem_map에서의 offset도 2의 거듭제곱의 배수가 될 것이다. 최종 결과로 주소 비트의 오른쪽에는 항상 최소 k개의 0이 존재할 것이다. 버디의 주소를 얻기 위해서, 오른쪽에서 k번째의 비트가 검사된다. 만약 0이라면, 버디는 해당 비트가 1일 것이다. 이 비트를 얻기위해 리눅스는 mask를 다음과 같이 계산한다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  mask <span style="color:#f92672">=</span> (<span style="color:#ae81ff">0</span> <span style="color:#f92672">&lt;&lt;</span> k)
</code></pre></div><p>우리가 관심있는 mask는 다음과 같다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  imask <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> mask
</code></pre></div><p>리눅스는 이를 다음과 같이 이를 간단히 계산한다:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  imask <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>mask <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> mask
</code></pre></div><p>버디가 병합되고나면, 기존의 free list에서 제거되고 새로 생긴 블록에 대해 다음 order로 넘어가 다시 병합될 수 있는 지를 확인하게된다.</p>
<h2 id="64-get-free-page-gfp-flags">6.4 Get Free Page (GFP) Flags</h2>
<p>전체 VM에 대해 항상 적용되는 개념은 Get Free Page (GFP) flag이다. 이 플래그들은 할당자와 <strong>kswapd</strong>가 페이지를 할당 또는 해제할 때 어떻게 동작할 지를 결정한다. 예를 들어, __GFP_WAIT 플래그는 호출자가 sleep 상태를 허용한다는 것을 의미하기 때문에, 인터럽트 핸들러는 이를 설정하지 않을 것이다. 세 집합의 GFP 플래그가 있으며, 이들은 모두 &lt;linux/mm.h&gt;에 정의되어있다.</p>
<p>셋 중 첫 번째는 zone modifiers이며 Table 6.3에 나와있다. 이 플래그들은 호출자가 특정 존에서 할당을 시도해야한다는 것을 나타낸다. 눈치빠른 독자들은 ZONE_NORMAL을 위한 플래그가 없다는 것을 알아챘을 것이다. 이는 해당 플래그들이 배열의 오프셋으로 사용되며, 0인 경우에는 암시적으로 ZONE_NORMAL에서의 할당을 의미하기 때문이다.</p>
<hr>






  
  
  


  




<div class="table-wrapper" role="region" tabindex="0" aria-labelledby="table-caption-582419637">
  <table class="table " id="582419637" itemscope itemtype="https://schema.org/Table"><caption id="table-caption-582419637" itemprop="about">Table 6.3: Low Level GFP Flags Affecting Zone Allocation</caption>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>__GFP_DMA</td>
<td>가능하면 ZONE_DMA에서 할당한다.</td>
</tr>
<tr>
<td>__GFP_HIGHMEM</td>
<td>가능하면 ZONE_HIGHMEM에서 할당한다.</td>
</tr>
<tr>
<td>GFP_DMA</td>
<td>__GFP_DMA의 alias이다.</td>
</tr>
</tbody>
</table>

</div>

<hr>
<p>다음 플래그들은 action modifiers로 Table 6.4에 나와있다. 이들은 VM의 동작과 호출 프로세스가 무엇을 할 것인지를 결정한다. 이들에 대한 low level 플래그들은 쉽게 사용하기에는 너무 원시적이다.</p>
<hr>






  
  
  


  




<div class="table-wrapper" role="region" tabindex="0" aria-labelledby="table-caption-926738514">
  <table class="table " id="926738514" itemscope itemtype="https://schema.org/Table"><caption id="table-caption-926738514" itemprop="about">Table 6.4: Low Level GFP Flags Affecting Affecting Allocator behaviour</caption>
<thead>
<tr>
<th>Flag</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>__GFP_WAIT</td>
<td>호출자가 높은 우선순위가 아니며 sleep하거나 reschedule해도된다는 것을 나타낸다.</td>
</tr>
<tr>
<td>__GFP_HIGH</td>
<td>높은 우선순위 또는 커널 프로세스가 사용한다. Kernel 2.2.x는 이것을 프로세스가 메모리의 긴급 pool에 접근가능한 지를 결정하기위해 사용했다. 2.4.x 커널에서는 이것이 사용되지않는다.</td>
</tr>
<tr>
<td>__GFP_IO</td>
<td>호출자가 저수준 IO를 수행할 수 있는지를 나타낸다. 2.4.x에서 이것은 주로 try_to_free_buffers()가 버퍼를 flush 할지 말지를 결정하는데 사용된다. 이는 최소한 하나의 journaled filesystem에 의해 사용되고있다.</td>
</tr>
<tr>
<td>__GFP_HIGHIO</td>
<td>High memory에 매핑된 페이지에 대해 IO를 수행할 수 있는지를 결정한다. try_to_free_buffers()에서만 사용된다.</td>
</tr>
<tr>
<td>__GFP_FS</td>
<td>호출자가 파일시스템 계층에 대한 호출을 수행할 수 있는지를 나타낸다. 호출자가 파일시스템과 관련이 있고 재귀적으로 호출되는 것을 피하기위해 사용되며, buffer cache를 예로 들 수 있다.</td>
</tr>
</tbody>
</table>

</div>

<hr>
<p>각 인스턴스의 정확한 조합이 무엇인지를 아는 것은 어렵기 때문에, 몇개의 high level 조합이 정의되어 있으며, Table 6.5에서 확인할 수 있다. 편의를 위해 __GFP_를 생략했기 때문에, __GFP_HIGH 플래그는 아래에서 HIGH로 쓰여져있을 것이다. 각 조합에 대한 설명은 Table 6.6에 나와있다. 이해를 돕기위해, GFP_ATOMIC을 예로들어 설명하겠다. 이것은 오직 __GFP_HIGH 플래그를 set한다. 이는 이것이 높은 우선순위임을 의미하며, emergency pool을 사용할 수 있고, sleep하지않으며, IO를 수행하거나 파일시스템에 접근하지 않을 것이다. 이 플래그는 인터럽트 핸들러가 사용할 것이다.</p>
<hr>






  
  
  


  




<div class="table-wrapper" role="region" tabindex="0" aria-labelledby="table-caption-931274685">
  <table class="table " id="931274685" itemscope itemtype="https://schema.org/Table"><caption id="table-caption-931274685" itemprop="about">Table 6.5: Low Level GFP Flag Combinations For High Level Use</caption>
<thead>
<tr>
<th>Flag</th>
<th>Low Level Flag Combination</th>
</tr>
</thead>
<tbody>
<tr>
<td>GFP_ATOMIC</td>
<td>HIGH</td>
</tr>
<tr>
<td>GFP_NOIO</td>
<td>HIGH | WAIT</td>
</tr>
<tr>
<td>GFP_NOHIGHIO</td>
<td>HIGH | WAIT | IO</td>
</tr>
<tr>
<td>GFP_NOFS</td>
<td>HIGH | WAIT | IO | HIGHIO</td>
</tr>
<tr>
<td>GFP_KERNEL</td>
<td>HIGH | WAIT | IO | HIGHIO | FS</td>
</tr>
<tr>
<td>GFP_NFS</td>
<td>HIGH | WAIT | IO | HIGHIO | FS</td>
</tr>
<tr>
<td>GFP_USER</td>
<td>WAIT | IO | HIGHIO | FS</td>
</tr>
<tr>
<td>GFP_HIGHUSER</td>
<td>WAIT | IO | HIGHIO | FS | HIGHMEM</td>
</tr>
<tr>
<td>GFP_KSWAPD</td>
<td>WAIT | IO | HIGHIO | FS</td>
</tr>
</tbody>
</table>

</div>

<hr>
<hr>






  
  
  


  




<div class="table-wrapper" role="region" tabindex="0" aria-labelledby="table-caption-134627958">
  <table class="table " id="134627958" itemscope itemtype="https://schema.org/Table"><caption id="table-caption-134627958" itemprop="about">Table 6.6: High Level GFP Flags Affecting Allocator Behaviour</caption>
<thead>
<tr>
<th>Flag</th>
<th>Low Level Flag Combination</th>
</tr>
</thead>
<tbody>
<tr>
<td>GFP_ATOMIC</td>
<td></td>
</tr>
<tr>
<td>GFP_NOIO</td>
<td></td>
</tr>
<tr>
<td>GFP_NOHIGHIO</td>
<td></td>
</tr>
<tr>
<td>GFP_NOFS</td>
<td></td>
</tr>
<tr>
<td>GFP_KERNEL</td>
<td></td>
</tr>
<tr>
<td>GFP_NFS</td>
<td></td>
</tr>
<tr>
<td>GFP_USER</td>
<td></td>
</tr>
<tr>
<td>GFP_HIGHUSER</td>
<td></td>
</tr>
<tr>
<td>GFP_KSWAPD</td>
<td></td>
</tr>
</tbody>
</table>

</div>

<hr>

    </div>
</article>

    </main>
    <script src="/js/scripts.js"></script>
</body>
</html>

